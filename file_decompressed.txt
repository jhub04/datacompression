#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass fu-leksjon
\begin_preamble

\usepackage{multicol}
\renewcommand{\forfatter}{Helge Hafting}

\let\Bbbk\relax
\usepackage{mtpro2}
% Added by lyx2lyx
\setlength{\parskip}{\smallskipamount}
\setlength{\parindent}{0pt}
\end_preamble
\use_default_options true
\begin_modules
svar
logicalmkup
\end_modules
\maintain_unincluded_children no
\language norsk
\language_package default
\inputencoding auto-legacy
\fontencoding auto
\font_roman "times" "TeX Gyre Termes"
\font_sans "helvet" "Open Sans"
\font_typewriter "courier" "TeX Gyre Cursor"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 92 92
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbh
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4
\use_geometry true
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Register
\shortcut idx
\color #008000
\end_index
\secnumdepth -2
\tocdepth 2
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style swiss
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Chapter
Ãving 6 algoritmer og datastrukturer
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Section
Innledning
\end_layout

\begin_layout Standard
Lag et program som kan lese en fil og lage en komprimert utgave.
 Lag et annet program som pakker ut igjen (dekomprimerer) og gjenskaper originalen.
 
\end_layout

\begin_layout Standard
For maksimal kompresjon,
 er det lurt Ã¥ bruke flere teknikker.
 Bruk gjerne bÃ¥de 
\series bold
Lempel-Ziv
\series default
 og 
\series bold
Huffmankoding
\series default
 for Ã¥ komprimere.
 LZ gjÃ¸r om fila til en blanding av bakoverreferanser og ukomprimerte strenger.
 Innholdet i de ukomprimerte strengene komprimeres videre med Huffmannkoding.
\end_layout

\begin_layout Standard
Det kan bli en del arbeid.
 HÃ¥ndtering av bits & bytes er nytt for mange.
 Jobb gjerne i grupper,
 og fordel arbeidet.
 
\emph on
Les hele oppgaveteksten fÃ¸r dere begynner,
 unngÃ¥ misforstÃ¥elser!
\end_layout

\begin_layout Standard
Det er anledning til Ã¥ jobbe i gruppe her,
 selv om man har jobbet alene pÃ¥ mindre Ã¸vinger.
\end_layout

\begin_layout Standard
Jeg kommer til Ã¥ lage en highscore-liste sortert pÃ¥ best kompresjon av 
\begin_inset Quotes cld
\end_inset

diverse.lyx
\begin_inset Quotes crd
\end_inset

.
 For Ã¥ komme pÃ¥ lista,
 mÃ¥ utpakkingen fungere feilfritt,
 og oppgaven vÃ¦re levert innen fristen.
 Den halvparten som ligger Ã¸verst pÃ¥ lista nÃ¥r fristen er ute,
 fÃ¥r et ekstra poeng pÃ¥ oppgaven.
 SÃ¥ her har dere et valg:
 Dere kan gjÃ¸re dette til en liten enkel oppgave med de vanlige to poengene,
 eller legge mer arbeid i det med hÃ¥p om Ã¥ fÃ¥ med ekstrapoenget ogsÃ¥.
\end_layout

\begin_layout Subsection
Testfiler for komprimering
\end_layout

\begin_layout Labeling
\labelwidthstring Forelesning~(pdf)
\noindent
Oppgave
\begin_inset space ~
\end_inset

(lyx) 
\size small

\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.idi.ntnu.no/emner/idatt2101/kompr/opg6-kompr.lyx
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring Forelesning~(pdf)
Jules
\begin_inset space ~
\end_inset

Verne 
\size small

\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.idi.ntnu.no/emner/idatt2101/kompr/Twenty_thousand_leagues_under_the_sea.txt
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring Forelesning~(pdf)
Forelesning
\begin_inset space ~
\end_inset

(txt) 
\size small

\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.idi.ntnu.no/emner/idatt2101/kompr/diverse.txt
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring Forelesning~(pdf)
Forelesning
\begin_inset space ~
\end_inset

(lyx) 
\size small

\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.idi.ntnu.no/emner/idatt2101/kompr/diverse.lyx
\end_layout

\end_inset


\end_layout

\begin_layout Labeling
\labelwidthstring Forelesning~(pdf)
100MB
\begin_inset space ~
\end_inset

enwik8 
\size small

\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.idi.ntnu.no/emner/idatt2101/kompr/enwik8
\end_layout

\end_inset


\end_layout

\begin_layout Standard
enwik8 er en diger fil,
 de fÃ¸rste 100MB av engelsk wikipedia.
 Dere trenger ikke hÃ¥ndtere den for Ã¥ fÃ¥ full uttelling,
 men har dere et 
\emph on
kjapt
\emph default
 program,
 er det jo artig Ã¥ prÃ¸ve.
 Denne fila brukes i rekordforsÃ¸k,
 der de beste har klart Ã¥ presse den sammen til ca.
 15MB.
 Det er pengepremier (Hutter-prisen) for de som setter nye rekorder.
\end_layout

\begin_layout Section
Krav til lÃ¸sningen
\end_layout

\begin_layout Enumerate
Send inn programmer for komprimering og dekomprimering,
 som klarer Ã¥ komprimere og pakke ut igjen minst to av testfilene.
 
\end_layout

\begin_layout Enumerate
Bruk en eller flere av algoritmene vi har sett pÃ¥.
 Ã kombinere flere,
 gir ofte bedre resultat.
 Dette kan gjÃ¸res med Ã¥ lage flere uavhengige programmer,
 eller ett program som implementerer flere teknikker.
\end_layout

\begin_layout Enumerate
Den komprimerte fila mÃ¥ vÃ¦re 
\emph on
mindre enn originalen.
 
\emph default
Dette mÃ¥les ved Ã¥ se pÃ¥ 
\emph on
filstÃ¸rrelser
\emph default
.
 
\end_layout

\begin_layout Enumerate
Dekomprimeringsprogrammet mÃ¥ greie Ã¥ gjenskape originalfila,
 nÃ¥r det bare har den komprimerte fila Ã¥ pakke ut.
\end_layout

\begin_deeper
\begin_layout Enumerate
Ingen ekstra filer,
 alt som trengs mÃ¥ finnes i den komprimerte fila.
 Dekompresjon mÃ¥ altsÃ¥ virke uten Ã¥ ha originalen tilgjengelig.
 
\end_layout

\begin_layout Enumerate
At utpakket fil er helt lik originalen,
 kan f.eks.
 testes med 
\begin_inset Quotes cld
\end_inset

fc
\begin_inset Quotes crd
\end_inset

 i windows,
 eller 
\begin_inset Quotes cld
\end_inset

diff
\begin_inset Quotes crd
\end_inset

 pÃ¥ linux/mac.
 UnngÃ¥ overraskelser,
 test selv fÃ¸r dere leverer.
\end_layout

\end_deeper
\begin_layout Enumerate
Dere mÃ¥ lage programmene selv,
 ikke noe 
\begin_inset Quotes cld
\end_inset

cut & paste
\begin_inset Quotes crd
\end_inset

 fra nettet.
 Det er mye Ã¥ lÃ¦re av Ã¥ gjÃ¸re en slik oppgave,
 som en ikke fÃ¥r med seg med 
\begin_inset Quotes cld
\end_inset

cut & paste
\begin_inset Quotes crd
\end_inset

.
 BÃ¥de nÃ¥r det gjelder algoritmene,
 og generell programmering.
 
\end_layout

\begin_layout Enumerate
Komprimering og utpakking 
\emph on
skal 
\emph default
skje i separate kjÃ¸ringer.
 Det er
\emph on
 ikke 
\emph default
greit Ã¥ ha ett samleprogram som bÃ¥de gjÃ¸r innpakking og utpakking i 
\emph on
en
\emph default
 operasjon!
 Utpakking skal 
\emph on
bare 
\emph default
trenge den komprimerte fila,
 ikke noen variabler/datastrukturer fra innpakkinga.
 Det sikres ved at inn- og utpakking 
\emph on
ikke 
\emph default
skjer i samme kjÃ¸ring.
\end_layout

\begin_deeper
\begin_layout Standard
Dere 
\emph on
kan 
\emph default
ha ett stort program som gjÃ¸r hele jobben,
 men det mÃ¥ i sÃ¥ fall vÃ¦re i to 
\emph on
separate
\emph default
 kjÃ¸ringer.
 Et slikt program mÃ¥ altsÃ¥ stoppe etter komprimering,
 og kjÃ¸res igang med andre parametre for Ã¥ pakke ut.
 Eller dere kan ha separate programmer.
\end_layout

\end_deeper
\begin_layout Enumerate
Programmene mÃ¥ lese og skrive 
\emph on
filer
\emph default
.
 AltsÃ¥ ikke bare testdata i en tabell.
 Filene ligger i den mappa programmet kjÃ¸rer i.
 Jeg mÃ¥ kunne teste pÃ¥ forskjellige filer.
\end_layout

\begin_layout Subsection
Tips for best kompresjon
\end_layout

\begin_layout Standard
Det enkleste er Ã¥ gjÃ¸re Huffman- og LZ-delene helt separat.
 Man kan fordele arbeidet pÃ¥ gruppa pÃ¥ denne mÃ¥ten,
 og sette sammen til slutt.
 Debuggingen blir ogsÃ¥ enklere.
 Men det er ikke dette som gir aller best kompresjon.
\end_layout

\begin_layout Standard
Lempel-Ziv lager koder for repeterte strenger,
 samt tekststrenger som ikke lot seg komprimere.
 Strengene som ikke lot seg komprimere med LZ,
 kan Huffman-delen ta seg av.
 Huffman-kompresjon fungerer vanligvis ikke sÃ¥ godt pÃ¥ kodene for repeterte strenger,
 sÃ¥ et smart Huffman-program kan skrive disse delene som de er,
 uten Ã¥ forsÃ¸ke Ã¥ komprimere dem.
 Et slikt opplegg blir som regel bedre,
 men er noe mer arbeid Ã¥ kode.
\end_layout

\begin_layout Standard
NÃ¥r LZ ser etter repeterte strenger,
 vil kompresjon avhenge av hvor langt bakover LZ leter,
 og hvor kompakte referanser dere klarer Ã¥ lage.
 Her er det rom for eksperimentering!
\end_layout

\begin_layout Standard
Run-length coding er enkelt,
 men oppnÃ¥r ikke mye pÃ¥ testfilene.
\end_layout

\begin_layout Subsection
Tips om hele oppgaven
\end_layout

\begin_layout Standard
Det er lett Ã¥ gjÃ¸re feil,
 og vanskelig Ã¥ debugge.
 NÃ¥r noe gÃ¥r galt,
 bruk testfiler som er sÃ¥ smÃ¥ at dere kan fÃ¸lge med pÃ¥ alt som skjer hele veien.
 F.eks.
 en testfil med bare 3â20 byte.
 Da blir det lettere Ã¥ se nÃ¥r noe gÃ¥r galt.
 En mÃ¥te er Ã¥ bruke en debugger som kan vise innholdet i variabler.
 En annen mÃ¥te er Ã¥ legge inn debug-utskrifter for Ã¥ se hva som skjer.
\end_layout

\begin_layout Standard
Om dere bruker flere teknikker,
 som LZ+Huffmann,
 er der lurt Ã¥ teste og lage LZ-delen og Huffmann-delen hver for seg.
 Programmer som zip gjÃ¸r alt i memory for Ã¥ vÃ¦re raske.
 Men det er ikke noe galt i Ã¥ ha ett program som gjÃ¸r LZ-komprimeringen og skriver sitt resultat til fil,
 og deretter et Huffmann-program som leser denne fila og skriver en ny og mer komprimert fil.
 Dekomprimering kan hÃ¥ndteres tilsvarende.
 Da kan hvert trinn testes og debugges for seg.
 Dette gjÃ¸r det ogsÃ¥ lettere Ã¥ dele pÃ¥ arbeidet i gruppa.
 
\end_layout

\begin_layout Subsubsection
Egne idÃ©er
\end_layout

\begin_layout Standard
Har dere egne idÃ©er om datakompresjon?
 PrÃ¸v det gjerne ut i oppgaven!
\end_layout

\begin_layout Subsubsection*
Bytes eller tekststrenger?
\end_layout

\begin_layout Standard
Jeg anbefaler Ã¥ se pÃ¥ fila som 
\begin_inset Quotes cld
\end_inset

et array med bytes
\begin_inset Quotes crd
\end_inset

,
 og lage et program som hÃ¥ndterer dette.
 Fordeler:
\end_layout

\begin_layout Itemize
Bytes fungerer for alt.
 Dere kan komprimere filer som ikke er tekst ogsÃ¥,
 som f.eks.
 .exe
\end_layout

\begin_layout Itemize
Ingen problemer med 
\begin_inset Quotes cld
\end_inset

Ã¦Ã¸Ã¥
\begin_inset Quotes crd
\end_inset

 eller data som ikke en gang er gyldig unicode.
\end_layout

\begin_layout Standard
Mange liker likevel Ã¥ jobbe med tekststrenger.
 Det har noen fordeler:
\end_layout

\begin_layout Itemize
Kan bruke velkjente strengoperasjoner.
 (Men de fÃ¥ man trenger her,
 er ikke sÃ¥ vanskelige Ã¥ re-implementere for byte-arrayâ¦)
\end_layout

\begin_layout Itemize
For debugging er det lett Ã¥ skrive ut tekst pÃ¥ skjermen
\end_layout

\begin_layout Standard
Men det er mange ulemper ogsÃ¥.
 En ting er at programmet begrenses til Ã¥ bare jobbe med tekst.
 Mange fÃ¥r problemer med 
\begin_inset Quotes cld
\end_inset

Ã¦Ã¸Ã¥
\begin_inset Quotes crd
\end_inset

,
 og med alle de andre unicodetegnene jeg bruker.
 For Ã¥ skrive norsk,
 brukes ihvertfall 
\begin_inset Quotes cld
\end_inset

Ã¦Ã¸Ã¥Ã©Ã´
\begin_inset Quotes crd
\end_inset

.
 Ellers forekommer 
\begin_inset Quotes cld
\end_inset

â¢âÎ©\SpecialChar ldots

\begin_inset Quotes crd
\end_inset

 og anfÃ¸rselstegn.
 De som jobber linjeorientert,
 fÃ¥r gjerne linjeskift som et vanskelig spesialtilfelle.
 Bytes har ikke slike problemer.
\end_layout

\begin_layout Section
Tips om Lempel-Ziv
\end_layout

\begin_layout Subsection
Filer
\end_layout

\begin_layout Standard
Normalt blir det veldig lite kompresjon pÃ¥ smÃ¥ filer.
 BittesmÃ¥ filer kan brukes for Ã¥ debugge programmet,
 men for Ã¥ teste kompresjon bÃ¸r filene vÃ¦re noen titalls kilobyte.
\end_layout

\begin_layout Standard
Det blir noen avgjÃ¸relser Ã¥ ta,
 som f.eks.
 hvor langt bakover programmet deres skal lete etter repeterte sekvenser.
 Zip leter 32kB bakover,
 det fins ogsÃ¥ versjoner som gÃ¥r 64kB tilbake.
 Hvis dere lar programmet gÃ¥ lenger tilbake,
 vil det bli tregere men sannsynligvis komprimere bedre ogsÃ¥.
\end_layout

\begin_layout Standard
Om en vil ha et veldig kjapt program,
 kan det lÃ¸nne seg Ã¥ la seg inspirere av avanserte tekstsÃ¸kalgoritmer.
 
\end_layout

\begin_layout Subsubsection
Filformat
\end_layout

\begin_layout Standard
Filformat bestemmer dere selv.
 Det kan fort bli en avveiing mellom hvor komplisert programmet skal vÃ¦re,
 og hvor godt det skal komprimere.
\end_layout

\begin_layout Standard
Den komprimerte fila kan bestÃ¥ av blokker.
 Hver blokk starter med en byte-verdi,
 som er et tall mellom -128 og +127.
 Hvis tallet er negativt,
 f.eks.
 -57,
 betyr det at det er en serie med tegn som ikke lot seg komprimere.
 (I dette eksempelet,
 57 tegn).
 
\end_layout

\begin_layout Standard
Hvis tallet er positivt,
 angir det lengden pÃ¥ en repetert sekvens.
 De neste 1,
 2 eller 4 byte er et heltall som forteller hvor langt bakover i fila denne sekvensen er Ã¥ finne.
 Med 1
\begin_inset space \thinspace{}
\end_inset

byte (byte) er det bare mulig Ã¥ gÃ¥ 127 tegn bakover.
 Programmet blir raskt,
 men komprimerer ikke sÃ¥ kraftig.
 Med 2
\begin_inset space \thinspace{}
\end_inset

byte (short) gÃ¥r det an Ã¥ gÃ¥ opp til 32
\begin_inset space \thinspace{}
\end_inset

kB bakover,
 men vi bruker altsÃ¥ opp en ekstra byte.
 Med 4
\begin_inset space \thinspace{}
\end_inset

byte (int) kan vi gÃ¥ opp til 2
\begin_inset space \thinspace{}
\end_inset

GB bakover.
 Det gir mange flere muligheter for Ã¥ finne repeterte strenger,
 men bruker ogsÃ¥ mer plass.
 Et program som leter opptil 2
\begin_inset space \thinspace{}
\end_inset

GB bakover,
 blir sannsynligvis temmelig tregt ogsÃ¥.
 Det kan lÃ¸nne seg Ã¥ begrense litt\SpecialChar ldots

\end_layout

\begin_layout Subsection
Litt om Ã¥ kombinere LZ og Huffmann
\end_layout

\begin_layout Standard
Det enkleste er Ã¥ gjÃ¸re de to delene separat.
 I sÃ¥ fall komprimerer man med LZ fÃ¸rst,
 og deretter med Huffmann.
 PrÃ¸v gjerne omvendt,
 men ikke regn med god kompresjon pÃ¥ det viset.
\end_layout

\begin_layout Standard
Man kan fÃ¥ bedre kompresjon ved Ã¥ se pÃ¥ hva slags data LZ lager.
 Referanser bakover er et antall byte som blir temmelig tilfeldig.
 Tilfeldige data komprimeres ikke bra med Huffmann,
 sÃ¥ det er bedre Ã¥ holde slikt utenfor slik at Huffmann bare komprimerer data og ikke disse referansene.
 Antall byte som refereres har derimot en kjent fordeling;
 det er mange fler referanser til korte data (ord o.l.) enn lange strenger.
 SÃ¥ Huffmannkomprimering kan brukes pÃ¥ strenglengder.
 Beste mÃ¥te er i sÃ¥ fall Ã¥ ha ett huffmantre for data,
 og et annet tre for strenglengder.
 Da kan begge deler kodes med ganske korte koder.
 
\end_layout

\begin_layout Section
Litt om Lempel-Ziv-Welsh
\end_layout

\begin_layout Standard
LZW bygger opp en ordbok/dictionary,
 og sparer plass ved Ã¥ angi ordnumre i stedet for Ã¥ lagre ordene i output.
 Til Ã¥ begynne med inneholder ordboka de 256 mulige enkeltbytes,
 som har numre fra 0 til 255.
 Kompresjon oppnÃ¥s ved Ã¥ legge til ord (eller bokstavkombinasjoner) som forekommer ofte.
 Ulike mÃ¥ter for Ã¥ legge til ord eller kortere sekvenser,
 gir ulik kompresjon.
 Man kan legge inn hver eneste sekvens som dukker opp:
 man fÃ¥r raskt noe Ã¥ komprimere,
 men fÃ¥r fort sÃ¥ mange 
\begin_inset Quotes cld
\end_inset

ord
\begin_inset Quotes crd
\end_inset

 at det trengs mange bits for Ã¥ referere til dem.
 En annen mÃ¥te er Ã¥ legge inn nye ord bare nÃ¥r de forekommer for andre eller tredje gang.
 FÃ¦rre ord i ordboka,
 men de man fÃ¥r,
 forekommer oftere.
 Det kan gi bedre kompresjon.
\end_layout

\begin_layout Standard
Man lagrer aldri ordboka.
 Hele poenget med LZW er at utpakkingsdelen kan bygge opp ordboka pÃ¥ samme mÃ¥te som innpakkingsdelen gjorde,
 ved Ã¥ se pÃ¥ hva som har blitt pakket ut sÃ¥ langt.
 Plass spares ved at numrene som regel er kortere enn ord/tegnsekvenser de refererer til.
\end_layout

\begin_layout Standard
Det er mange mÃ¥ter Ã¥ dele opp i ord.
 Man kan dele opp i faktiske ord,
 og slik fÃ¥ nytte av at forfatteren har et begrensa ordforrÃ¥d som gir fÃ¥ ulike numre.
 Eller man kan se pÃ¥ mindre biter,
 og fÃ¥ nytte av at mange ord inneholder de samme stavelsene.
 Ikke glem Ã¥ fÃ¥ med mellomrommene ogsÃ¥â¦
\end_layout

\begin_layout Subsection
Kombinere LZW og Huffmann
\end_layout

\begin_layout Standard
LZW lager en output som bestÃ¥r av numre.
 I begynnelsen numre for diverse bytes,
 etterhvert ogsÃ¥ numre for ord som LZW har oppdaget.
 Man kan telle opp hvor mange det er av hvert nummer,
 og lage et Huffmantre.
 De ord/bytes som forekommer ofte,
 fÃ¥r da korte Huffmannkoder og vi sparer mer plass.
\end_layout

\begin_layout Section
Om Huffmankoding
\end_layout

\begin_layout Standard
Lag et program som leser inn en fil,
 teller frekvenser og genererer en huffmanntre ut fra byte-verdiene i filen.
 Deretter bruker programmet huffmanntreet til Ã¥ skrive en komprimert huffmannkodet fil.
 
\end_layout

\begin_layout Standard
For Ã¥ pakke ut,
 trenger utpakkingsprogrammet nok informasjon til Ã¥ gjenskape huffmantreet.
 Det enkleste er Ã¥ legge frekvenstabellen fÃ¸rst i den komprimerte fila.
 
\end_layout

\begin_layout Standard
Adaptiv huffmankoding er en mer avansert lÃ¸sning.
 For Ã¥ slippe overhead med en lagret tabell,
 skriver man heller en 
\begin_inset Quotes cld
\end_inset

blokk
\begin_inset Quotes crd
\end_inset

 uten kompresjon.
 Neste blokk komprimeres med et huffmanntre basert pÃ¥ forrige blokk.
 Poenget med dette,
 er at utpakkingsprogrammet kan gjÃ¸re det samme.
 Et problem med slike lÃ¸sninger,
 er at en blokk kan inneholde tegn som ikke var i den forrige blokka,
 og det mÃ¥ hÃ¥ndteres.
 En mÃ¥te er Ã¥ gi tegn som ikke er med,
 en lav frekvens i stedet for 0.
 En annen mÃ¥te er Ã¥ ha en escape-kode for slike tilfeller.
 NÃ¥r programmet dekoder en escapekode,
 leser det deretter inn et tegn som ikke er komprimert med huffmannkoding.
 
\end_layout

\begin_layout Subsection
Tips om Huffmankoding
\end_layout

\begin_layout Subsubsection
Huffmanndata som trengs for Ã¥ pakke ut igjen
\end_layout

\begin_layout Standard
Det er ikke nÃ¸dvendig Ã¥ lagre huffmanntreet,
 det holder Ã¥ lagre frekvenstabellen.
 Utpakkingsprogrammet kan dermed bygge opp samme tre ut fra frekvensene.
 
\end_layout

\begin_layout Kode-liten
int frekvenser[256];
\end_layout

\begin_layout Standard
En slik frekvenstabell blir alltid 1
\begin_inset space \thinspace{}
\end_inset

kB.
 Filen som skal komprimeres mÃ¥ dermed vÃ¦re stor nok til at komprimeringen sparer mer enn 1
\begin_inset space \thinspace{}
\end_inset

kB.
 Testfilene jeg lenker til,
 skulle vÃ¦re store nok.
\end_layout

\begin_layout Subsubsection
Om bitstrenger
\end_layout

\begin_layout Standard
En bitstreng er 
\emph on
ikke 
\emph default
en streng som dette:
 "00001101".
 Dette er en 
\emph on
tekststreng 
\emph default
med 8
\begin_inset space \thinspace{}
\end_inset

tegn.
 Skriver vi dette til en fil,
 gÃ¥r det med 8
\begin_inset space \thinspace{}
\end_inset

byte,
 og vi oppnÃ¥r ikke noe datakompresjon.
 Tvert imot fÃ¥r vi en veldig stor fil!
\end_layout

\begin_layout Standard
Men bitstrengen 0b00001101 er det samme som tallet 13,
 og kan lagres som Ã©n byte.
\end_layout

\begin_layout Standard
Datatypen 
\begin_inset Quotes cld
\end_inset

long
\begin_inset Quotes crd
\end_inset

 er pÃ¥ 64 bit.
 Ingen tegn vil trenge lenger Huffmankode enn det.
 (Det kan vises at nÃ¥ man komprimerer en fil pÃ¥ 2.7GB,
 trenger ingen tegn kodes med mer enn 44 bit.) 
\begin_inset Quotes cld
\end_inset

long
\begin_inset Quotes crd
\end_inset

 er dermed egnet til Ã¥ lagre bitstrenger.
 En 
\begin_inset Quotes cld
\end_inset

long
\begin_inset Quotes crd
\end_inset

 har alltid 64 bit,
 sÃ¥ en bitstreng-klasse mÃ¥ ogsÃ¥ ha et felt som forteller hvor mange av bitene som er med i bitstrengen.
\end_layout

\begin_layout Standard
Ã skrive bitstrenger til fil,
 blir en del ekstra arbeid.
 Java lar oss bare skrive hele byte,
 og for Ã¥ vÃ¦re effektive bÃ¸r vi bare skrive byte-array av en viss stÃ¸rrelse.
 Men,
 med hÃ¸yre/venstreskift samt binÃ¦re & og | -operasjoner,
 kan vi fÃ¥ vÃ¥re bitstrenger inn i et byte-array som sÃ¥ kan skrives til disk.
 
\end_layout

\begin_layout Standard
Tilsvarende for lesing:
 Vi leser inn et byte-array,
 og plukker deretter ut Ã©n og Ã©n bit for Ã¥ navigere gjennom huffmanntreet.
\end_layout

\begin_layout Subsection
Delvis uttelling
\end_layout

\begin_layout Standard
Ikke gi opp,
 om hele oppgaven blir for vanskelig.
 Delvis uttelling for oppgaver som:
\end_layout

\begin_layout Itemize
Har noen fÃ¥ feil ved utpakking.
 Her mÃ¥ jeg kunne se at fila som pakkes ut har mye av det samme innholdet,
 sÃ¥ det gÃ¥r ikke med bare rot.
 Men noen feil her og der,
 holder til delvis uttelling.
\end_layout

\begin_layout Itemize
Klarer Ã¥ pakke inn/ut deres egne testfiler,
 men ikke mine.
 Send i sÃ¥ fall med en testfil som fungerer.
 Det hender f.eks.
 at noen lager programmer som bare hÃ¥ndterer ascii,
 eller bare veldig korte filer.
\end_layout

\begin_layout Section
Javatips for begge deloppgaver
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="right" valignment="top">
<column alignment="right" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Datatype
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
byte
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
min
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
max
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-128
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
127
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-32
\begin_inset space \thinspace{}
\end_inset

768
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\begin_inset space \thinspace{}
\end_inset

767
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65
\begin_inset space \thinspace{}
\end_inset

535
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-2147483648
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2147483647
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-9223372036854775808
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
9223372036854775807
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Programmer som leser Ã©n og Ã©n byte fra fil,
 blir alltid trege i Java.
 For Ã¥ fÃ¥ noe fart i sakene,
 lÃ¸nner det seg Ã¥ lese/skrive stÃ¸rre blokker,
 f.eks.
 et array med bytes.
 Men det er ikke et krav,
 poenget er kompresjon,
 ikke hastighet.
 
\end_layout

\begin_layout Standard
Noe bitfikling blir det uansett med Huffmannoppgaven.
 Det gÃ¥r ikke an Ã¥ skrive 
\begin_inset Quotes cld
\end_inset

en halv byte
\begin_inset Quotes crd
\end_inset

 til fil,
 man mÃ¥ i det minste samle opp bits til man har en hel byte.
 Det kan vÃ¦re lurt Ã¥ lage en egen klasse for Ã¥ sende bitstrenger til fil.
\end_layout

\begin_layout Subsection
Noen kodeeksempler,
 bitoperasjoner og filbehandling
\end_layout

\begin_layout Kode-liten
//Ãpne filer:
\end_layout

\begin_layout Kode-liten
innfil = new DataInputStream(new BufferedInputStream(new FileInputStream(inn_navn)));
\end_layout

\begin_layout Kode-liten
utfil = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(ut_navn)));
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//Lese data fra fil inn i byte-array:
\end_layout

\begin_layout Kode-liten
//   byte []data  :
 arrayet vi leser inn i
\end_layout

\begin_layout Kode-liten
//   int posisjon :
 index i byte-array for det vi leser inn
\end_layout

\begin_layout Kode-liten
//   int mengde   :
 antall byte vi vil lese inn
\end_layout

\begin_layout Kode-liten
innfil.readFully(data,
 posisjon,
 mengde);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//Lese inn Ã©n byte
\end_layout

\begin_layout Kode-liten
byte x;
\end_layout

\begin_layout Kode-liten
x = innfil.readByte();
\end_layout

\begin_layout Kode-liten
//Har ogsÃ¥:
\end_layout

\begin_layout Kode-liten
short s = innfil.readShort();
\end_layout

\begin_layout Kode-liten
char c = innfil.readChar();
\end_layout

\begin_layout Kode-liten
int i = innfil.readInt();
\end_layout

\begin_layout Kode-liten
long l = innfil.readLong();
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//Skrive data fra byte-array til fil:
\end_layout

\begin_layout Kode-liten
utfil.write(data,
 posisjon,
 mengde);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//Skrive Ã©n byte til fil:
\end_layout

\begin_layout Kode-liten
byte singlebyte = 17;
\end_layout

\begin_layout Kode-liten
utfil.writeByte(singlebyte);
\end_layout

\begin_layout Kode-liten
//Har ogsÃ¥:
 
\end_layout

\begin_layout Kode-liten
//utfil.writeChar(char c);
 
\end_layout

\begin_layout Kode-liten
//utfil.writeShort(short s);
\end_layout

\begin_layout Kode-liten
//utfil.writeInt(int i);
   
\end_layout

\begin_layout Kode-liten
//utfil.writeLong(long l);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//Hente 13 bit fra long1,
 8 bit fra long2 og 4 bit fra long3,
 
\end_layout

\begin_layout Kode-liten
//og fÃ¥ det inn i et byte-array:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

byte[] data = new byte[3];
\end_layout

\begin_layout Kode-liten
long long1 = 0b1101000010011;
 //13 bit
\end_layout

\begin_layout Kode-liten
long long2 = 0b11100111;
      //8 bit
\end_layout

\begin_layout Kode-liten
long long3 = 0b010;
           //3 bit
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//8 fÃ¸rste bit fra long1 til data[0]
\end_layout

\begin_layout Kode-liten
//Ã¸vrige bits maskeres bort med &
\end_layout

\begin_layout Kode-liten
data[0] = (byte)(long1 & 0b11111111);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//5 gjenvÃ¦rende bit fra long1 til data[1]
\end_layout

\begin_layout Kode-liten
//hÃ¸yreskiftet fjerner bits vi allerede har lagt i data[0]
\end_layout

\begin_layout Kode-liten
//trenger ikke maskere fordi resterende bits i long1 er 0.
\end_layout

\begin_layout Kode-liten
data[1] = (byte)(long1 >> 8);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//data[1] har plass til 3 av de 8 bit fra long2
\end_layout

\begin_layout Kode-liten
//venstreskifter 5 plasser fordi de 5 fÃ¸rste bits i data[1] er i bruk fra fÃ¸r
\end_layout

\begin_layout Kode-liten
//trenger ikke maskere vekk bits fordi bits over 256 ikke gÃ¥r inn i en byte uansett
\end_layout

\begin_layout Kode-liten
data[1] |= (byte)(long2 << 5);
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//5 gjenvÃ¦rende bit fra long2 til data[2]
\end_layout

\begin_layout Kode-liten
//hÃ¸yreskift fjerner de bits vi allerede la i data[1]
\end_layout

\begin_layout Kode-liten
data[2] = (byte)(long2 >> 3);
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

//data[2] har plass til de 3 bit fra long3
\end_layout

\begin_layout Kode-liten
data[2] |= (byte)(long3 << 5);
\end_layout

\begin_layout Kode-liten
System.out.printf("%x %x %x
\backslash
n",
 data[0],
 data[1],
 data[2]);
\end_layout

\end_body
\end_document
